/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <functional>
#include <map>
#include <memory>
#include <ostream>
#include <string>
#include <variant>
#include <vector>

#include "flashlight/fl/tensor/Index.h"
#include "flashlight/fl/tensor/TensorAdapter.h"
#include "flashlight/fl/tensor/TensorBase.h"

namespace fl {

/**
 * An interface for implementing custom tracers on Tensor operations.
 *
 * Tracers must be able to receive arguments of any types present in the Tensor
 * API. These are enumerated in the ArgumentTypes variant and can be expanded as
 * the API changes.
 *
 * Tracing data is passed via maps of string key names to ArgumentTypes. Traced
 * tensor operations created via trace(...) have three parts:
 * 1. general operation argument metadata
 * 2. input data to operators
 * 3. output data generated by an operator
 *
 * Operations are written to a std::ostream which is owned by the tracer. To
 * multiplex ostreams, multiple tracer instances should be used in cases where
 * tracers don't own internal state.
 */
class TracerBase {
  std::unique_ptr<std::ostream> ostream_;

 protected:
  bool tracingEnabled_{true};

 public:
  TracerBase() = default;
  virtual ~TracerBase() = default;

  /**
   * Construct a TracerBase.
   *
   * @param[in] stream an ostream pointer that the tracer will own and write to
   */
  explicit TracerBase(std::unique_ptr<std::ostream> stream);

  // A possible argument type to trace.
  using ArgumentTypes = std::variant<
      std::reference_wrapper<const Tensor>,
      std::reference_wrapper<const Index>,
      std::reference_wrapper<const std::vector<Index>>, // indices
      std::vector<int>, // axes
      std::vector<std::pair<int, int>>, // padWidths
      std::reference_wrapper<const std::vector<Tensor>>,
      double,
      int,
      bool,
      unsigned,
      long,
      unsigned long,
      unsigned long long,
      fl::dtype,
      Dim, // axis
      Shape,
      SortMode,
      PadType,
      MatrixProperty, // matmul
      Location, // i.e. memory
      StorageType, // sparse
      std::string // labels
      >;
  using ArgumentList = std::map<
      std::string, // argument name
      ArgumentTypes>;

  class TraceDataFactory;

  struct TraceData {
    std::string opName;
    std::string args{"{}"};
    std::string inputs{"{}"};
    std::string outputs{"{}"};

    static std::unique_ptr<TraceDataFactory> build(
        TracerBase& tracer,
        std::string opName) {
      return std::make_unique<TraceDataFactory>(tracer, opName);
    }
  };

  class TraceDataFactory {
    TracerBase& tracer_;
    TraceData data_;

   public:
    TraceDataFactory(TracerBase& tracer, std::string opName)
        : tracer_(tracer), data_({opName}) {}

    TraceDataFactory* setArgs(ArgumentList args) {
      data_.args = tracer_.traceArgumentList(args);
      return this;
    }

    TraceDataFactory* setInputs(ArgumentList inputs) {
      data_.inputs = tracer_.traceArgumentList(inputs);
      return this;
    }

    TraceDataFactory* setOutputs(ArgumentList outputs) {
      data_.outputs = tracer_.traceArgumentList(outputs);
      return this;
    }

    TraceData build() {
      return std::move(data_);
    }
  };

  void enableTracer(bool val);

  /**
   * @return if tracing is enabled
   */
  bool tracingEnabled() const;

  /**
   * Get a reference to the stream associated with this tracer.
   */
  const std::ostream& getStream() const;

  /**
   * Non-const getter for stream for use as an lvalue
   */
  std::ostream& getStream();

  /**
   * Set the stream associated with this tracer to which traces will be written
   * out.
   *
   * @param[in] stream a pointer to the new ostream to use.
   */
  void setStream(std::unique_ptr<std::ostream> stream);

  /**
   * Convert an ArgumentList into its string representation.
   */
  virtual std::string traceArgumentList(ArgumentList args) {
    return "";
  }

  virtual void trace(TraceData data) {}

  /**
   * Trace operations with a given name.
   *
   * @param[in] funcName the name of the op/function to trace
   * @param[in] args map of string-key delimited argument metadata to trace
   * @param[in] inputs map of string-key delimited input arguments to the
   * operator
   * @param[in] outputs map of string-key delimited output arguments to the
   * operator
   */
  virtual void trace(
      const std::string& /* funcName */,
      ArgumentList /* args */,
      ArgumentList /* inputs */,
      ArgumentList /* outputs */) {}
};

} // namespace fl
